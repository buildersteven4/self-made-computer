-- Instruction layout
[ opcode:6 | mode A:1 | mode B:1 ][ address A:4 | address B:4 ][ #:16 ]
opcode: Determines what operation to execute.
A: output and secondary input. The operation will be 8 or 16-bit corresponding to A.
B: primary input
mode A&B: Determines the addressing mode of A and B (register if 0, ram if 1)
address A&B: The address of the register if the respective mode bit is 0, or if the respective mode bit is 1 it determines the addressing mode.
#: The immidiate number, used in instructions that have mode A or B set to 1.

-- Addressing modes A:
(8-bit)
	0x0 = [ax + #]
	0x1 = [bx + #]
	0x2 = [cx + #]
	0x3 = [dx + #]
	0x4 = [fx + #]
	0x5 = [cs + #]
	0x6 = [ss + #]
	0x7 = [#]
(16-bit)
	0x8 = @[ax + #]
	0x9 = @[bx + #]
	0xA = @[cx + #]
	0xB = @[dx + #]
	0xC = @[fx + #]
	0xD = @[cs + #]
	0xE = @[ss + #]
	0xF = @[#]

-- Addressing modes B:
(read from RAM)
	0x0 = [ax + #]
	0x1 = [bx + #]
	0x2 = [cx + #]
	0x3 = [dx + #]
	0x4 = [fx + #]
	0x5 = [cs + #]
	0x6 = [ss + #]
	0x7 = [#]
(use the calculated number)
	0x8 = ax + #
	0x9 = bx + #
	0xA = cx + #
	0xB = dx + #
	0xC = fx + #
	0xD = cs + #
	0xE = ss + #
	0xF = #

-- Registers
(general purpose registers)
	0x0 = al (8-bit) : The lower byte of ax
	0x1 = ah (8-bit) : The higher byte of ax
	0x2 = bl (8-bit) : The lower byte of bx
	0x3 = bh (8-bit) : The higher byte of bx
	0x4 = cl (8-bit) : The lower byte of cx
	0x5 = ch (8-bit) : The higher byte of cx
	0x6 = dl (8-bit) : The lower byte of dx
	0x7 = dh (8-bit) : The higher byte of dx
	0x8 = ax (16-bit):
	0x9 = bx (16-bit):
	0xA = cx (16-bit):
	0xB = dx (16-bit):
	0xC = ex (16-bit):
	0xD = fx (16-bit): Meant for very temporary data
(special purpose registers)
	0xE = as (16-bit): holds input A of the current operation if input A is from the RAM
	0xF = bs (16-bit): holds input B of the current operation if input B is from the RAM

-- Flags
(status flags)
	0x0 = ZF : zero flag
	0x1 = SF : sign flag
	0x2 = PF : parity flag
	0x3 = OF : overflow flag
	0x4 = CF : carry & borrow flag
(control flags)
	0x5 = IF : enable interrupt flag

-- Conditions
	0x0 = Z		   : zero flag is set (number is equal to zero)
	0x1 = NZ	   : zero flag is clear (number is not equal to zero)
	0x2 = S  & NSZ : sign flag is set (number is positive or zero)
	0x3 = NS & SZ  : sign flag is clear (number is negative)
	0x4 = P		   : parity flag is set (number is even)
	0x5 = NP	   : parity flag is clear (number is uneven)
	0x6 = O		   : overflow flag is set (the last operation had an overflow)
	0x7 = NO	   : overflow flag is clear (the last operation didn't have an overflow)
	0x8 = C		   : carry flag is set (the last operation had a carry or borrow)
	0x9 = NC	   : carry flag is clear (the last operation didn't have a carry or borrow)
	0xA = LZ	   : sign flag is set and zero flag is clear (number is positive)
	0xB = NLZ	   : sign flag is clear or zero flag is set (number is negative or zero)
	0xC = I		   : enable interrupt flag is set (interrupts will fire)
	0xD = NI	   : enable interrupt flag is clear (interrupts won't fire)
	0xE = A		   : always
	0xF = NA	   : never

-- OPcodes
(move opcodes)
	0x00-0x0F = MOV a b: moves value from B to A if the condition (determined by the first 4 bits of the opcode) is met

(special opcodes)
	0x10 = 
	0x11 = 
	0x12 = 
	0x13 = 
	0x14 = 
	0x15 = 
	0x16 = 
	0x17 = 

	0x18 = INT _ _: backups all the registers and starts the interrupt handler
	0x19 = IRET _ _: restores all the registers and returns from the interrupt handler
	0x1A = STI _ b: writes the least significant bit of b to IF (enables/disables interrupts)
	0x1B = HLT _ _: halts the CPU untill an external interrupt is triggered
	0x1C = OUT a b : write b to output register a
	0x1D = IN a b : request input from pheripiral b and write that to a
	0x1E = CMP a b :
	0x1F = TEST a b : 

(ALU opcodes)
	0x20 = OR a b
	0x21 = OR !a b
	0x22 = OR a !b
	0x23 = OR !a !b
	0x24 = AND a b
	0x25 = AND !a b
	0x26 = AND a !b
	0x27 = AND !a !b

	0x28 = XOR a b
	0x29 = XOR !a b
	0x2A = XOR a !b (duplicate)
	0x2B = XOR !a !b (useless)
	0x2C = ADD a b
	0x2D = ADD !a b
	0x2E = ADD a !b
	0x2F = ADD !a !b (useless)

	0x30 = ADD1 a b
	0x31 = ADD1 !a b
	0x32 = ADD1 a !b
	0x33 = ADD1 !a !b (useless)
	0x34 = ADDC a b
	0x35 = ADDC !a b
	0x36 = ADDC a !b
	0x37 = ADDC !a !b (useless)

	0x38 = SHL a b
	0x39 = SHL1 a b
	0x3A = RCL a b
	0x3B = ROL a b
	0x3C = SHR a b
	0x3D = SHR1 a b
	0x3E = RCR a b
	0x3F = ROR a b

-- pseudo instructions
	NOT a    = OR !a 0x0
	XAND a b = XOR a !b
	NOR a b  = AND !a !b
	NAND a b = OR !a !b
	SUB a b  = ADD a !b
	SUB1 a b = ADD1 a !b
	SUBB a b = ADDC a !b
	NEG a    = ADD !a 0x0
	NOP a    = MOVNA ax ax
	PUSH a   = MOV [ss] a 
	           ADD ss (0x1 or 0x2)
	POP a    = SUB ss (0x1 or 0x2) 
	           MOV a [ss]
	CALL a   = MOV fx cs+0x
	           MOV [ss] fx 
			   ADD1 ss 0x2
			   MOV cs a
	RET      = SUB ss 0x2 
	           MOV cs [ss]

-- micro instructions
carry: Effects the output of the operations 0x5, 0x6 and 0x7. "carry" will be inverted if either "not A" or "not B" is set.
not A: Inverts bits of input A.
not B: Inverts bits of input B.
operation: Determines what operation's answer to output.
	0x0: pass A
	0x1: pass B
	0x2: shift left B
	0x3: shift right B
	0x4: or
	0x5: and
	0x6: exclusive or
	0x7: add
test: will update status flags
