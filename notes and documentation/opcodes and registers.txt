-- Instruction l
ayout
[ opcode:6 | mode A:1 | mode B:1 ][ address A:4 | address B:4 ] -> [ #:16 ]
opcode: Determines what operation to execute.
A: output and secondary input. The operation will be 8 or 16-bit corresponding to A.
B: primary input
mode A&B: Determines the addressing mode of A and B (register if 0, ram if 1), if any of these is set the cpu will load the next 2 bytes as an extra argument for this instruction.
address A&B: The address of the register if the respective mode bit is 0, or if the respective mode bit is 1 it determines the addressing mode.

-- Addressing modes A:
(8-bit)
	0x0 = [ax + #]
	0x1 = [bx + #]
	0x2 = [cx + #]
	0x3 = [dx + #]
(16-bit)
	0x4 = @[ax + #]
	0x5 = @[bx + #]
	0x6 = @[cx + #]
	0x7 = @[dx + #]
(8-bit)
	0x8 = [cs + #]
	0x9 = [ss + #]
	0xA = [zs + #] or [#]
	0xB = [os + #] or [1 + #]
(16-bit)
	0xC = @[cs + #]
	0xD = @[ss + #]
	0xE = @[zs + #] or @[#]
	0xF = @[os + #] or @[1 + #]

-- Addressing modes B:
	0x0 = [ax + #]
	0x1 = [bx + #]
	0x2 = [cx + #]
	0x3 = [dx + #]
	0x4 = ax + #
	0x5 = bx + #
	0x6 = cx + #
	0x7 = dx + #
	0x8 = [cs + #]
	0x9 = [ss + #]
	0xA = [zs + #] or [#]
	0xB = [os + #] or [1 + #]
	0xC = cs + #
	0xD = ss + #
	0xE = zs + # or #
	0xF = os + # or 1 + #

-- Registers
(general purpose registers)
	0x0 = al (8-bit) : The low byte of ax
	0x1 = ah (8-bit) : The high byte of ax
	0x2 = bl (8-bit) : The low byte of bx
	0x3 = bh (8-bit) : The high byte of bx
	0x4 = ax (16-bit): 
	0x5 = bx (16-bit):
	0x6 = cx (16-bit):
	0x7 = dx (16-bit):
(special purpose registers)
	0x8 = fs (8-bit) : holds the flags
	0x9 = is (8-bit) : interrupt register
	0xA = zs (8-bit) : hardwired to zero. The input is ignored and the output is always zero.
	0xB = os (8-bit) : hardwired to one. The input is ignored and the output is always one.
	0xC = cs (16-bit): holds the address of the next operation to run
	0xD = ss (16-bit): holds the address of the end of the stack
	0xE = as (16-bit): holds input A of the current operation if input A is from the RAM
	0xF = bs (16-bit): holds input B of the current operation if input B is from the RAM

-- Flags
(status flags)
	0x0 = ZF : zero flag
	0x1 = SF : sign flag
	0x2 = PF : parity flag
	0x3 = CF : carry & borrow flag
	0x4 = OF : overflow flag
(control flags)
	0x5 = TF : trap flag?
	0x6 = IF : enable interrupt flag?
	0x7 = DR : direction flag?

-- Conditions
	0x0 = Z		   : zero flag is set (number is equal to zero)
	0x1 = NZ	   : zero flag is clear (number is not equal to zero)
	0x2 = S  & NSZ : sign flag is set (number is positive or zero)
	0x3 = NS & SZ  : sign flag is clear (number is negative)
	0x4 = P		   : parity flag is set (number is even)
	0x5 = NP	   : parity flag is clear (number is uneven)
	0x6 = C		   : carry flag is set (the last operation had a carry or borrow)
	0x7 = NC	   : carry flag is clear (the last operation didn't have a carry or borrow)
	0x8 = O		   : overflow flag is set (the last operation had an overflow)
	0x9 = NO	   : overflow flag is clear (the last operation didn't have an overflow)
	0xA = LZ	   : sign flag is set and zero flag is clear (number is positive)
	0xB = NLZ	   : sign flag is clear or zero flag is set (number is negative or zero)
	0xC = ??	   : reserved
	0xD = ??	   : reserved
	0xE = A		   : always
	0xF = NA	   : never

-- OPcodes
(move opcodes)
	0x00-0x0F = MOV : moves value from B to A if the condition (determined by the first 4 bits of the opcode) is met

(special opcodes)
	0x10 = 
	0x11 = 
	0x12 = 
	0x13 = 
	0x14 = 
	0x15 = 
	0x16 = 
	0x17 = 

	0x18 = EXIT : shutdown
	0x19 = 
	0x1A = 
	0x1B = 
	0x1C = 
	0x1D = 
	0x1E = 
	0x1F = 

(ALU opcodes)
	0x20 = OR a b
	0x21 = OR !a b
	0x22 = OR a !b
	0x23 = OR !a !b
	0x24 = AND a b
	0x25 = AND !a b
	0x26 = AND a !b
	0x27 = AND !a !b

	0x28 = XOR a b
	0x29 = XOR !a b
	0x2A = XOR a !b (useless)
	0x2B = XOR !a !b (useless)
	0x2C = ADD a b
	0x2D = ADD !a b
	0x2E = ADD a !b
	0x2F = ADD !a !b (useless)

	0x30 = ADD1 a b
	0x31 = ADD1 !a b
	0x32 = ADD1 a !b
	0x33 = ADD1 !a !b (useless)
	0x34 = ADDC a b
	0x35 = ADDC !a b
	0x36 = ADDC a !b
	0x37 = ADDC !a !b (useless)

	0x38 = SHL a b
	0x39 = SHL1 a b
	0x3A = RCL a b
	0x3B = ROL a b
	0x3C = SHR a b
	0x3D = SHR1 a b
	0x3E = RCR a b
	0x3F = ROR a b

-- pseudo instructions
	NOT a = OR !a zs
	XAND a b = XOR a !b
	NOR a b = AND !a !b
	NAND a b = OR !a !b
	SUB a b = ADD a !b
	SUB1 a b = ADD1 a !b
	SUBB a b = ADDC a !b
	NEG a = ADD !a zs
	TEST a = OR zs a
	NOP a = MOV-NA zs zs
	PUSH a = MOV [ss] a ADD1 ss zs/os
	POP a = SUB1 ss zs/os MOV a [ss]
	CALL a = MOV bs ss+# MOV [ss] bs ADD1 ss os MOV cs a
	RET = ADD1 ss !os MOV cs [ss+2]

-- micro instructions
carry: Effects the output of the operations 0x5, 0x6 and 0x7. "carry" will be inverted if either "not A" or "not B" is set.
not A: Inverts bits of input A.
not B: Inverts bits of input B.
operation: Determines what operation's answer to output.
	0x0: pass A
	0x1: pass B
	0x2: shift left B
	0x3: shift right B
	0x4: or
	0x5: and
	0x6: exclusive or
	0x7: add
test: will update status flags
